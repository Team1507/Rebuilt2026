//  ██╗    ██╗ █████╗ ██████╗ ██╗      ██████╗  ██████╗██╗  ██╗███████╗
//  ██║    ██║██╔══██╗██╔══██╗██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝
//  ██║ █╗ ██║███████║██████╔╝██║     ██║   ██║██║     █████╔╝ ███████╗
//  ██║███╗██║██╔══██║██╔══██╗██║     ██║   ██║██║     ██╔═██╗ ╚════██║
//  ╚███╔███╔╝██║  ██║██║  ██║███████╗╚██████╔╝╚██████╗██║  ██╗███████║
//   ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝
//                           TEAM 1507 WARLOCKS

package frc.lib.io.swerve;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import frc.robot.Constants.kSwerve;
import frc.robot.generated.ctre.CommandSwerveDrivetrain;

import com.ctre.phoenix6.swerve.SwerveRequest;
import com.ctre.phoenix6.swerve.SwerveModule;

/**
 * Real hardware implementation of SwerveIO using CTRE's
 * CommandSwerveDrivetrain generated by Phoenix Tuner X.
 *
 * This version uses FieldCentric control exactly like the
 * original RobotContainer drive code.
 */
public class SwerveIOReal implements SwerveIO {

    private final CommandSwerveDrivetrain drivetrain;

    // Reusable request object (mirrors RobotContainer)
    private final SwerveRequest.FieldCentric fieldCentric =
        new SwerveRequest.FieldCentric()
            .withDeadband(kSwerve.MAX_SPEED * 0.1)
            .withRotationalDeadband(kSwerve.MAX_ANGULAR_RATE * 0.1)
            .withDriveRequestType(SwerveModule.DriveRequestType.OpenLoopVoltage);

    private final SwerveRequest.Idle idle = new SwerveRequest.Idle();

    public SwerveIOReal(CommandSwerveDrivetrain drivetrain) {
        this.drivetrain = drivetrain;
    }

    @Override
    public void updateInputs(SwerveInputs inputs) {
        var state = drivetrain.getState();
        inputs.pose = state.Pose;
        inputs.speeds = state.Speeds;
        inputs.moduleStates = state.ModuleStates;
    }

    @Override
    public void drive(ChassisSpeeds speeds) {
        drivetrain.setControl(
            fieldCentric
                .withVelocityX(speeds.vxMetersPerSecond)
                .withVelocityY(speeds.vyMetersPerSecond)
                .withRotationalRate(speeds.omegaRadiansPerSecond)
        );
    }

    @Override
    public void driveRobotRelative(ChassisSpeeds speeds) {
        drivetrain.setControl(
            new SwerveRequest.ApplyRobotSpeeds()
                .withSpeeds(speeds)
        );
    }

    @Override
    public void setModuleStates(SwerveModuleState[] states) {
        // Your CTRE version does NOT support ApplyModuleStates
        // so we simply idle or ignore this request.
        drivetrain.setControl(idle);
    }

    @Override
    public Pose2d getPose() {
        return drivetrain.getState().Pose;
    }

    @Override
    public void resetPose(Pose2d pose) {
        drivetrain.resetPose(pose);
    }

    @Override
    public void addVisionMeasurement(Pose2d pose, double timestamp, Matrix<N3, N1> stdDevs) {
        drivetrain.addVisionMeasurement(pose, timestamp, stdDevs);
    }

    @Override
    public void alignGyro(Rotation2d heading) {
        drivetrain.getPigeon2().setYaw(heading.getDegrees());
    }

    @Override
    public Rotation2d getHeading() {
        return drivetrain.getPigeon2().getRotation2d();
    }

    @Override
    public void stop() {
        drivetrain.setControl(idle);
    }
}
